"""
Backtest module
Use backtrader to implement backtest functionality
"""

import backtrader as bt
from langchain.agents import tool
from langchain.chat_models import ChatOpenAI
import pandas as pd
import numpy as np
from typing import List, Dict, Any, Union
from datetime import datetime
from utils.logger import setup_logger
from config.settings import (
    INITIAL_CAPITAL,
    COMMISSION_RATE
)
from core.tools.Indicators_process import get_historical_data, calculate_indicators
from core.tools.Strategy_generation import generate_live_signal
import json

logger = setup_logger(__name__)

class BacktestEngine:
    def __init__(self):
        """Initialize backtest engine"""
        self.cerebro = bt.Cerebro()
        self.cerebro.broker.setcash(INITIAL_CAPITAL)
        self.cerebro.broker.setcommission(commission=COMMISSION_RATE)
        self.cerebro.addsizer(bt.sizers.PercentSizer, percents=10)  # 每次交易10%仓位
        self.strategy_config = None
        
        # Add analyzers
        self.cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name='sharpe')
        self.cerebro.addanalyzer(bt.analyzers.DrawDown, _name='drawdown')
        self.cerebro.addanalyzer(bt.analyzers.TradeAnalyzer, _name='trades')
        self.cerebro.addanalyzer(bt.analyzers.Returns, _name='returns')

    def set_data(self, data: pd.DataFrame) -> None:
        """
        Set backtest data
        
        Args:
            data: DataFrame containing historical prices and technical indicators
        """
        if not isinstance(data, pd.DataFrame):
            raise ValueError("Backtest data must be a pandas DataFrame")
            
        required_columns = ['OPEN', 'HIGH', 'LOW', 'CLOSE', 'VOLUME']
        if not all(col in data.columns for col in required_columns):
            raise ValueError("Backtest data must contain OHLCV data")
            
        # Convert data format
        data = data.rename(columns={
            'OPEN': 'open',
            'HIGH': 'high',
            'LOW': 'low',
            'CLOSE': 'close',
            'VOLUME': 'volume'
        })
        
        # Add data to backtest engine
        datafeed = bt.feeds.PandasData(dataname=data)
        self.cerebro.adddata(datafeed)

    def add_strategy(self, strategy_config: Dict[str, Any]) -> None:
        """
        Add strategy
        
        Args:
            strategy_config: Strategy configuration dictionary, generated by generate_strategies
        """
        self.strategy_config = strategy_config
        
        # Create strategy class
        class Strategy(bt.Strategy):
            def __init__(self):
                self.indicators = {}
                for indicator in strategy_config['indicators']:
                    params = strategy_config['params'].get(indicator, {})
                    self.indicators[indicator] = getattr(bt.indicators, indicator)(**params)
                    
            def next(self):
                if self.order:
                    return
                    
                rule = strategy_config['rule']
                if not self.position:
                    if eval(rule, {
                        'close': self.data.close[0],
                        **{k: v[0] for k, v in self.indicators.items()}
                    }):
                        self.buy()
                else:
                    if not eval(rule, {
                        'close': self.data.close[0],
                        **{k: v[0] for k, v in self.indicators.items()}
                    }):
                        self.close()
                        
        self.cerebro.addstrategy(Strategy)

    def run_backtest(self) -> Dict[str, Any]:
        """
        Run backtest
        
        Returns:
            Dict[str, Any]: Backtest results
        """
        # Run backtest
        results = self.cerebro.run()
        
        # Get backtest results
        strat = results[0]
        
        # Calculate backtest metrics
        total_return = (self.cerebro.broker.getvalue() / INITIAL_CAPITAL) - 1
        
        # Calculate annualized return
        days = (strat.data.datetime.date(-1) - strat.data.datetime.date(0)).days
        annual_return = (1 + total_return) ** (365 / days) - 1
        
        # Calculate maximum drawdown
        drawdown = strat.analyzers.drawdown.get_analysis()
        max_drawdown = drawdown['max']['drawdown'] / 100
        
        # Calculate Sharpe ratio
        sharpe = strat.analyzers.sharpe.get_analysis()
        sharpe_ratio = sharpe['sharperatio']
        
        # Calculate win rate
        trades = strat.analyzers.trades.get_analysis()
        win_rate = trades['won'] / trades['total'] if trades['total'] > 0 else 0
        
        return {
            'strategy_name': self.strategy_config['name'],
            'total_return': total_return,
            'annual_return': annual_return,
            'max_drawdown': max_drawdown,
            'sharpe_ratio': sharpe_ratio,
            'win_rate': win_rate,
            'total_trades': trades['total'],
            'trades': trades,
            'equity_curve': strat.analyzers.returns.get_analysis()
        }


def backtest_strategy(data: pd.DataFrame,
                       strategy: Dict[str, Any],
                       initial_capital: float = 100000.0) -> Dict[str, Any]:
    """
    Backtest a single trading strategy
    
    Args:
        data: Backtest data
        strategy: Strategy configuration dictionary
        initial_capital: Initial capital
        
    Returns:
        Dict[str, Any]: Backtest results
    """
    engine = BacktestEngine()
    engine.set_data(data)
    engine.add_strategy(strategy)
    return engine.run_backtest()

def evaluate_backtest(backtest_results: Dict[str, Any]) -> Dict[str, Any]:
    """
    Evaluate backtest results and generate detailed performance analysis report
    
    Args:
        backtest_results: Backtest results dictionary, containing strategy name, return, drawdown, etc.
        
    Returns:
        Dict[str, Any]: Dictionary containing detailed evaluation metrics
    """
    # Basic metrics
    total_return = backtest_results['total_return']
    annual_return = backtest_results['annual_return']
    max_drawdown = backtest_results['max_drawdown']
    sharpe_ratio = backtest_results['sharpe_ratio']
    win_rate = backtest_results['win_rate']
    total_trades = backtest_results['total_trades']
    
    # Calculate risk-adjusted return metrics
    sortino_ratio = annual_return / (max_drawdown + 1e-6)  # Sortino ratio
    calmar_ratio = annual_return / (max_drawdown + 1e-6)   # Calmar ratio
    
    # Transaction statistics
    trades = backtest_results['trades']
    avg_trade_return = trades['pnl']['net']['average'] if 'pnl' in trades else 0
    profit_factor = trades['pnl']['net']['total'] / abs(trades['pnl']['net']['total'] - trades['pnl']['gross']['total']) if 'pnl' in trades else 0
    
    # Fund curve analysis
    equity_curve = backtest_results['equity_curve']
    equity_series = pd.Series(equity_curve)
    volatility = equity_series.pct_change().std() * np.sqrt(252)  # Annualized volatility
    
    # Calculate consecutive loss times
    consecutive_losses = 0
    max_consecutive_losses = 0
    for trade in trades.get('trades', []):
        if trade['pnl'] < 0:
            consecutive_losses += 1
            max_consecutive_losses = max(max_consecutive_losses, consecutive_losses)
        else:
            consecutive_losses = 0
    
    # Generate evaluation report
    evaluation_report = {
        'strategy_name': backtest_results['strategy_name'],
        'performance_metrics': {
            'total_return': total_return,
            'annual_return': annual_return,
            'max_drawdown': max_drawdown,
            'sharpe_ratio': sharpe_ratio,
            'sortino_ratio': sortino_ratio,
            'calmar_ratio': calmar_ratio,
            'volatility': volatility
        },
        'trading_statistics': {
            'total_trades': total_trades,
            'win_rate': win_rate,
            'profit_factor': profit_factor,
            'avg_trade_return': avg_trade_return,
            'max_consecutive_losses': max_consecutive_losses
        },
        'risk_metrics': {
            'value_at_risk_95': equity_series.pct_change().quantile(0.05),
            'expected_shortfall': equity_series.pct_change()[equity_series.pct_change() <= equity_series.pct_change().quantile(0.05)].mean()
        }
    }
    
    # Add evaluation conclusion
    evaluation_report['conclusion'] = {
        'overall_rating': 'Excellent' if (sharpe_ratio > 1.5 and win_rate > 0.6 and max_drawdown < 0.2) else 
                         'Good' if (sharpe_ratio > 1.0 and win_rate > 0.5 and max_drawdown < 0.3) else 
                         'Average' if (sharpe_ratio > 0.5 and win_rate > 0.4 and max_drawdown < 0.4) else 'Poor',
        'strengths': [],
        'weaknesses': []
    }
    
    # Analyze strengths and weaknesses
    if sharpe_ratio > 1.0:
        evaluation_report['conclusion']['strengths'].append('Risk-adjusted return performance is excellent')
    if win_rate > 0.6:
        evaluation_report['conclusion']['strengths'].append('High win rate')
    if max_drawdown < 0.2:
        evaluation_report['conclusion']['strengths'].append('Good drawdown control')
        
    if sharpe_ratio < 0.5:
        evaluation_report['conclusion']['weaknesses'].append('Risk-adjusted return performance is poor')
    if win_rate < 0.4:
        evaluation_report['conclusion']['weaknesses'].append('Low win rate')
    if max_drawdown > 0.3:
        evaluation_report['conclusion']['weaknesses'].append('Large drawdown')
    
    # Add is_satisfactory flag based on key metrics
    evaluation_report['is_satisfactory'] = (
        sharpe_ratio > 1.0 and  # 夏普比率大于1
        win_rate > 0.5 and      # 胜率大于50%
        max_drawdown < 0.3 and  # 最大回撤小于30%
        total_trades >= 10      # 至少有10笔交易
    )
    
    return evaluation_report

@tool("根据用户请求的资产代码和策略配置，进行量化分析即先获取历史数据，然后计算技术指标，再获取实时交易信号，运行回测，评估回测结果，最终返回包含实盘交易信号的JSON格式的回测结果报告")
def quant_analysis(symbol: str, strategy: Dict[str, Any]) -> Dict[str, Any]:
    """
    运行量化交易回测
    
    Args:
        symbol: 资产代码，例如 'AAPL'
        strategy: 策略配置字典，包含策略参数
        
    Returns:
        Dict[str, Any]: 回测结果报告
    """
    try:
        # 1. 获取历史数据
        historical_data = get_historical_data(symbol)
        if historical_data is None:
            raise ValueError(f"无法获取资产 {symbol} 的历史数据")
            
        # 2. 计算技术指标
        data_with_indicators = calculate_indicators(historical_data)
        if data_with_indicators is None:
            raise ValueError("计算技术指标失败")
            
        # 3. 获取实时交易信号
        try:
            live_signal = generate_live_signal(data_with_indicators, strategy)
        except Exception as e:
            logger.warning(f"获取实时交易信号失败: {str(e)}")
            live_signal = "HOLD"  # 默认持有
            
        # 4. 运行回测
        backtest_result = backtest_strategy(
            data=data_with_indicators,
            strategy=strategy,
            initial_capital=INITIAL_CAPITAL
        )
        
        # 5. 评估回测结果
        evaluation = evaluate_backtest(backtest_result)
        
        # 6. 生成回测报告
        report = {
            'status': 'success',
            'symbol': symbol,
            'strategy_name': strategy['name'],
            'backtest_period': {
                'start_date': historical_data.index[0].strftime('%Y-%m-%d'),
                'end_date': historical_data.index[-1].strftime('%Y-%m-%d')
            },
            'live_signal': live_signal,  # 添加实时交易信号
            'performance_metrics': evaluation['performance_metrics'],
            'trading_statistics': evaluation['trading_statistics'],
            'risk_metrics': evaluation['risk_metrics'],
            'conclusion': evaluation['conclusion'],
            'is_satisfactory': evaluation['is_satisfactory']  # 添加策略满意度标志
        }
        
        return report
        
    except Exception as e:
        logger.error(f"量化交易回测运行失败: {str(e)}")
        return {
            'status': 'error',
            'symbol': symbol,
            'error': str(e)
        }
    
def generate_live_signal(data: pd.DataFrame, strategy: Dict[str, Any]) -> Dict[str, Any]:
    """
    Generate a live trading signal using LLM based on live data and trading strategy
    
    Args:
        data: Live data, containing technical indicators
        strategy: Strategy configuration dictionary
        
    Returns:
        Dict[str, Any]: The dictionary containing the trading signal
    """
    try:
        # Get the latest data point
        latest_data = data.iloc[-1]
        
        # Build prompt
        prompt = f"""
        You are an expert quant trader.
        Please determine whether to buy, sell, or hold based on the following technical indicator data and trading strategy:
        
        Current price: {latest_data['CLOSE']}
        Technical indicators:
        {json.dumps({indicator: latest_data[indicator] for indicator in strategy['indicators']}, indent=2)}
        
        Trading strategy:
        {json.dumps(strategy, indent=2, ensure_ascii=False)}
        
        Please only answer: BUY, SELL or HOLD
        """
        
        # Call LLM to get signal
        response = llm.invoke(prompt)
        signal = response.strip().upper()
        
        # Validate signal validity
        if signal not in ["BUY", "SELL", "HOLD"]:
            signal = "HOLD"  # Default hold
            
        # Return signal details
        return signal
        
    except Exception as e:
        logger.error(f"Error generating trading signal: {str(e)}")
        raise 

# Initialize LLM and parser
llm = ChatOpenAI(model="gpt-4o", temperature=0.2)    
