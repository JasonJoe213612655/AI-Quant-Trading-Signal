"""
Backtest module
Use backtrader to implement backtest functionality
"""

import backtrader as bt
from langchain.agents import tool
from langchain.chat_models import ChatOpenAI
import pandas as pd
import numpy as np
from typing import List, Dict, Any, Union
from datetime import datetime
from utils.logger import setup_logger
from config.settings import (
    INITIAL_CAPITAL,
    COMMISSION_RATE
)
from core.tools.indicators_process import get_historical_data, calculate_indicators
import json

logger = setup_logger(__name__)

class BacktestEngine:
    def __init__(self):
        """Initialize backtest engine"""
        self.cerebro = bt.Cerebro()
        self.cerebro.broker.setcash(INITIAL_CAPITAL)
        self.cerebro.broker.setcommission(commission=COMMISSION_RATE)
        self.cerebro.addsizer(bt.sizers.PercentSizer, percents=10)  # 10% of position per trade
        self.strategy_config = None
        
        # Add analyzers
        self.cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name='sharpe')
        self.cerebro.addanalyzer(bt.analyzers.DrawDown, _name='drawdown')
        self.cerebro.addanalyzer(bt.analyzers.TradeAnalyzer, _name='trades')
        self.cerebro.addanalyzer(bt.analyzers.Returns, _name='returns')

    def set_data(self, data: pd.DataFrame) -> None:
        """
        Set backtest data
        
        Args:
            data: DataFrame containing historical prices and technical indicators
        """
        if not isinstance(data, pd.DataFrame):
            raise ValueError("Backtest data must be a pandas DataFrame")
            
        required_columns = ['OPEN', 'HIGH', 'LOW', 'CLOSE', 'VOLUME']
        if not all(col in data.columns for col in required_columns):
            raise ValueError("Backtest data must contain OHLCV data")
            
        # Convert data format
        data = data.rename(columns={
            'OPEN': 'open',
            'HIGH': 'high',
            'LOW': 'low',
            'CLOSE': 'close',
            'VOLUME': 'volume'
        })
        
        # Add data to backtest engine
        datafeed = bt.feeds.PandasData(dataname=data)
        self.cerebro.adddata(datafeed)

    def add_strategy(self, strategy_config: Dict[str, Any]) -> None:
        """
        Add strategy
        
        Args:
            strategy_config: Strategy configuration dictionary, generated by generate_strategies
        """
        logger.info(f"Adding strategy: {strategy_config.get('name', 'Unnamed Strategy')}")
        logger.debug(f"Strategy configuration: {json.dumps(strategy_config, indent=2, ensure_ascii=False)}")
        
        # 处理规则格式
        if isinstance(strategy_config['rule'], str):
            # 如果是字符串格式，转换为列表格式
            strategy_config['rule'] = [
                {
                    "type": "entry",
                    "expr": strategy_config['rule']
                },
                {
                    "type": "exit",
                    "expr": strategy_config['rule'].replace('>', '<').replace('CrossOver(A, B) > 0', 'CrossOver(A, B) < 0')
                }
            ]
        
        self.strategy_config = strategy_config
        
        # Create strategy class
        class Strategy(bt.Strategy):
            def __init__(self):
                logger.info("Initializing strategy")
                self.indicators = {}
                for indicator in strategy_config['indicators']:
                    logger.info(f"Setting up indicator: {indicator}")
                    try:
                        params = strategy_config['params'].get(indicator, {})
                        logger.debug(f"Indicator parameters: {json.dumps(params, indent=2)}")
                        self.indicators[indicator] = getattr(bt.indicators, indicator)(**params)
                        logger.info(f"Successfully added indicator: {indicator}")
                    except Exception as e:
                        logger.error(f"Error setting up indicator {indicator}: {str(e)}", exc_info=True)
                        raise
                
                # 添加 CrossOver 指标
                logger.info("Adding CrossOver indicators")
                for rule in strategy_config['rule']:
                    if 'CrossOver' in rule['expr']:
                        # 解析 CrossOver 参数
                        expr = rule['expr']
                        if 'CrossOver(SMA, close)' in expr:
                            self.crossover_sma = bt.indicators.CrossOver(self.indicators['SMA'], self.data.close)
                            self.indicators['CrossOver_SMA'] = self.crossover_sma
                        elif 'CrossOver(EMA, close)' in expr:
                            self.crossover_ema = bt.indicators.CrossOver(self.indicators['EMA'], self.data.close)
                            self.indicators['CrossOver_EMA'] = self.crossover_ema
                        elif 'CrossOver(MACD, MACD_SIGNAL)' in expr:
                            self.crossover_macd = bt.indicators.CrossOver(self.indicators['MACD'], self.indicators['MACD_SIGNAL'])
                            self.indicators['CrossOver_MACD'] = self.crossover_macd
                    
            def next(self):
                # 检查是否有未完成的订单
                if len(self.broker.get_orders_open()) > 0:
                    logger.debug("Order pending, skipping strategy execution")
                    return
                
                # 准备指标值
                indicator_values = {
                    'close': self.data.close[0],
                    **{k: v[0] for k, v in self.indicators.items()}
                }
                logger.debug(f"Current indicator values: {json.dumps(indicator_values, indent=2)}")
                
                # 获取入场和出场规则
                entry_rule = next((rule['expr'] for rule in strategy_config['rule'] if rule['type'] == 'entry'), None)
                exit_rule = next((rule['expr'] for rule in strategy_config['rule'] if rule['type'] == 'exit'), None)
                
                if not self.position:
                    if entry_rule and eval(entry_rule, indicator_values):
                        logger.info("Entry signal triggered")
                        self.buy()
                else:
                    if exit_rule and eval(exit_rule, indicator_values):
                        logger.info("Exit signal triggered")
                        self.close()
                        
        logger.info("Strategy class created")
        self.cerebro.addstrategy(Strategy)
        logger.info("Strategy added to backtest engine")

    def run_backtest(self) -> Dict[str, Any]:
        """
        Run backtest
        
        Returns:
            Dict[str, Any]: Backtest results
        """
        # Run backtest
        results = self.cerebro.run()
        
        # Get backtest results
        strat = results[0]
        
        # Calculate backtest metrics
        total_return = (self.cerebro.broker.getvalue() / INITIAL_CAPITAL) - 1
        
        # Calculate annualized return
        days = (strat.data.datetime.date(-1) - strat.data.datetime.date(0)).days
        annual_return = (1 + total_return) ** (365 / days) - 1
        
        # Calculate maximum drawdown
        drawdown = strat.analyzers.drawdown.get_analysis()
        max_drawdown = drawdown['max']['drawdown'] / 100
        
        # Calculate Sharpe ratio
        sharpe = strat.analyzers.sharpe.get_analysis()
        sharpe_ratio = sharpe['sharperatio']
        
        # Calculate win rate
        trades = strat.analyzers.trades.get_analysis()
        win_rate = trades['won'] / trades['total'] if trades['total'] > 0 else 0
        
        return {
            'strategy_name': self.strategy_config['name'],
            'total_return': total_return,
            'annual_return': annual_return,
            'max_drawdown': max_drawdown,
            'sharpe_ratio': sharpe_ratio,
            'win_rate': win_rate,
            'total_trades': trades['total'],
            'trades': trades,
            'equity_curve': strat.analyzers.returns.get_analysis()
        }


def backtest_strategy(data: pd.DataFrame,
                       strategy: Dict[str, Any],
                       initial_capital: float = 100000.0) -> Dict[str, Any]:
    """
    Backtest a single trading strategy
    
    Args:
        data: Backtest data
        strategy: Strategy configuration dictionary
        initial_capital: Initial capital
        
    Returns:
        Dict[str, Any]: Backtest results
    """
    engine = BacktestEngine()
    logger.info(f"backtest engine set up")
    engine.set_data(data)
    logger.info(f"backtest engine set data")
    engine.add_strategy(strategy)
    logger.info(f"backtest engine add strategy")
    return engine.run_backtest()

def evaluate_backtest(backtest_results: Dict[str, Any]) -> Dict[str, Any]:
    """
    Evaluate backtest results and generate detailed performance analysis report
    
    Args:
        backtest_results: Backtest results dictionary, containing strategy name, return, drawdown, etc.
        
    Returns:
        Dict[str, Any]: Dictionary containing detailed evaluation metrics
    """
    # Basic metrics
    total_return = backtest_results['total_return']
    annual_return = backtest_results['annual_return']
    max_drawdown = backtest_results['max_drawdown']
    sharpe_ratio = backtest_results['sharpe_ratio']
    win_rate = backtest_results['win_rate']
    total_trades = backtest_results['total_trades']
    
    # Calculate risk-adjusted return metrics
    sortino_ratio = annual_return / (max_drawdown + 1e-6)  # Sortino ratio
    calmar_ratio = annual_return / (max_drawdown + 1e-6)   # Calmar ratio
    
    # Transaction statistics
    trades = backtest_results['trades']
    avg_trade_return = trades['pnl']['net']['average'] if 'pnl' in trades else 0
    profit_factor = trades['pnl']['net']['total'] / abs(trades['pnl']['net']['total'] - trades['pnl']['gross']['total']) if 'pnl' in trades else 0
    
    # Fund curve analysis
    equity_curve = backtest_results['equity_curve']
    equity_series = pd.Series(equity_curve)
    volatility = equity_series.pct_change().std() * np.sqrt(252)  # Annualized volatility
    
    # Calculate consecutive loss times
    consecutive_losses = 0
    max_consecutive_losses = 0
    for trade in trades.get('trades', []):
        if trade['pnl'] < 0:
            consecutive_losses += 1
            max_consecutive_losses = max(max_consecutive_losses, consecutive_losses)
        else:
            consecutive_losses = 0
    
    # Generate evaluation report
    evaluation_report = {
        'strategy_name': backtest_results['strategy_name'],
        'performance_metrics': {
            'total_return': total_return,
            'annual_return': annual_return,
            'max_drawdown': max_drawdown,
            'sharpe_ratio': sharpe_ratio,
            'sortino_ratio': sortino_ratio,
            'calmar_ratio': calmar_ratio,
            'volatility': volatility
        },
        'trading_statistics': {
            'total_trades': total_trades,
            'win_rate': win_rate,
            'profit_factor': profit_factor,
            'avg_trade_return': avg_trade_return,
            'max_consecutive_losses': max_consecutive_losses
        },
        'risk_metrics': {
            'value_at_risk_95': equity_series.pct_change().quantile(0.05),
            'expected_shortfall': equity_series.pct_change()[equity_series.pct_change() <= equity_series.pct_change().quantile(0.05)].mean()
        }
    }
    
    # Add evaluation conclusion
    evaluation_report['conclusion'] = {
        'overall_rating': 'Excellent' if (sharpe_ratio > 1.5 and win_rate > 0.6 and max_drawdown < 0.2) else 
                         'Good' if (sharpe_ratio > 1.0 and win_rate > 0.5 and max_drawdown < 0.3) else 
                         'Average' if (sharpe_ratio > 0.5 and win_rate > 0.4 and max_drawdown < 0.4) else 'Poor',
        'strengths': [],
        'weaknesses': []
    }
    
    # Analyze strengths and weaknesses
    if sharpe_ratio > 1.0:
        evaluation_report['conclusion']['strengths'].append('Risk-adjusted return performance is excellent')
    if win_rate > 0.6:
        evaluation_report['conclusion']['strengths'].append('High win rate')
    if max_drawdown < 0.2:
        evaluation_report['conclusion']['strengths'].append('Good drawdown control')
        
    if sharpe_ratio < 0.5:
        evaluation_report['conclusion']['weaknesses'].append('Risk-adjusted return performance is poor')
    if win_rate < 0.4:
        evaluation_report['conclusion']['weaknesses'].append('Low win rate')
    if max_drawdown > 0.3:
        evaluation_report['conclusion']['weaknesses'].append('Large drawdown')
    
    # Add is_satisfactory flag based on key metrics
    evaluation_report['is_satisfactory'] = (
        sharpe_ratio > 1.0 and
        win_rate > 0.5 and      
        max_drawdown < 0.3 and 
        total_trades >= 10      
    )
    
    return evaluation_report

@tool("quant_analysis")
def quant_analysis(symbol: str, strategy: dict) -> dict:
    """
    Performs quantitative analysis based on the given symbol and trading strategy.
    It retrieves historical data, calculates indicators, generates real-time signals,
    runs backtesting, and returns a JSON report.
    """
    try:
        # 1. Get historical data
        historical_data = get_historical_data(symbol)
        if historical_data is None:
            raise ValueError(f"Failed to get historical data for asset {symbol}")
        logger.info(f"got historical_data")
            
        # 2. Calculate technical indicators
        data_with_indicators = calculate_indicators(historical_data)
        if data_with_indicators is None:
            raise ValueError("Failed to calculate technical indicators")
        logger.info(f"calculated indicators")
            
        # 3. Get real-time trading signal
        try:
            live_signal = generate_live_signal(data_with_indicators, strategy)
        except Exception as e:
            logger.warning(f"Failed to get real-time trading signal: {str(e)}")
            live_signal = "HOLD"  # Default hold
        logger.info(f"generated live signal: {live_signal}")
            
        # 4. Run backtest
        backtest_result = backtest_strategy(
            data=data_with_indicators,
            strategy=strategy,
            initial_capital=INITIAL_CAPITAL
        )
        logger.info(f"backtest result: {backtest_result}")
        # 5. Evaluate backtest results
        evaluation = evaluate_backtest(backtest_result)
        logger.info(f"evaluation result: {evaluation}")
        # 6. Generate backtest report
        report = {
            'status': 'success',
            'symbol': symbol,
            'strategy_name': strategy['name'],
            'backtest_period': {
                'start_date': historical_data.index[0].strftime('%Y-%m-%d'),
                'end_date': historical_data.index[-1].strftime('%Y-%m-%d')
            },
            'live_signal': live_signal,  # Add real-time trading signal
            'performance_metrics': evaluation['performance_metrics'],
            'trading_statistics': evaluation['trading_statistics'],
            'risk_metrics': evaluation['risk_metrics'],
            'conclusion': evaluation['conclusion'],
            'is_satisfactory': evaluation['is_satisfactory']  # Add strategy satisfaction flag
        }
        
        return report
        
    except Exception as e:
        logger.error(f"Failed to run quantitative trading backtest: {str(e)}")
        return {
            'status': 'error',
            'symbol': symbol,
            'error': str(e)
        }
    
def generate_live_signal(data: pd.DataFrame, strategy: Dict[str, Any]) -> str:
    """
    Generate live trading signal based on the latest data and strategy
    
    Args:
        data: DataFrame containing historical prices and technical indicators
        strategy: Strategy configuration dictionary
        
    Returns:
        str: The trading signal (BUY/SELL/HOLD)
    """
    try:
        # Get latest data
        latest_data = data.iloc[-1]
        
        # Build prompt
        prompt = f"""
        You are an expert quant trader.
        Please determine whether to buy, sell, or hold based on the following data:
        
        Latest Market Data:
        {json.dumps(latest_data.to_dict(), indent=2, ensure_ascii=False)}
        
        Trading Strategy:
        {json.dumps(strategy, indent=2, ensure_ascii=False)}
        
        Please only answer: BUY, SELL or HOLD
        """
        
        # Call LLM to get signal
        response = llm.invoke(prompt)
        # 获取 AIMessage 的内容
        signal = response.content.strip().upper()
        logger.info(f"generated live signal: {signal}")
        
        # Validate signal validity
        if signal not in ["BUY", "SELL", "HOLD"]:
            signal = "HOLD"  # Default hold
            
        return signal
        
    except Exception as e:
        logger.error(f"Error generating live signal: {str(e)}", exc_info=True)
        return "HOLD"  # Default to HOLD on error

# Initialize LLM and parser
llm = ChatOpenAI(model="gpt-4o", temperature=0.2)    
